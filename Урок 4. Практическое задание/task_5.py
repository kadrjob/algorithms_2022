"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (в материалах есть его описание)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


# Решето Эратосфена
def task1(i):
    my_list = [x for x in range(2, i * 10)]
    p = 2
    while p < i:
        my_list = list(filter(lambda x: x % p != 0 or x == p, my_list))
        p = list(filter(lambda x: x > p, my_list))[0]

    # print(my_list)
    return my_list[i - 1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print(task1(i))

print(timeit(stmt='simple(i)', globals=globals(), number=1000))
print(timeit(stmt='task1(i)', globals=globals(), number=1000))
print('Эффективность алгоритма Эратосфена квадратично зависит от порядкового номера нужного числа.\n'
      'Чем порядковый номер необходимого числа выше, тем алгоритм оправданнее по сравнению \n'
      'с алгоритмом через перебор делителей (работает на порядок быстрее)\n'
      'Прирост в скорости начинается с 50 числа')

"""
Результаты
Введите порядковый номер искомого простого числа: 10
29
29
0.04228826600000035
0.05700684299999992

Введите порядковый номер искомого простого числа: 100
541
541
3.188521743
1.5560361510000007
Эффективность алгоритма Эратосфена квадратично зависит от порядкового номера нужного числа.
Чем порядковый номер необходимого числа выше, тем алгоритм оправданнее по сравнению 
с алгоритмом через перебор делителей (работает на порядок быстрее)
Прирост в скорости начинается с 50 числа

"""